# JavaScript学習まとめ - 2025-10-27

## 📚 今日学んだこと

---

## 1. 時間帯に応じた挨拶機能

### 概要
現在時刻を取得して、時間帯（朝・昼・夜）に応じて異なる挨拶を表示する機能。

### 使用した技術
- `new Date()`: 現在の日時を取得
- `getHours()`: 時刻（0-23）を取得
- `if-else if`文: 条件分岐

### コード例
```javascript
// 現在時刻取得
const now = new Date();

function getGreetMessage(hour) {
    if (hour >= 4 && hour <= 10) {
        return "おはよう";
    }
    else if (hour >= 11 && hour <= 16) {
        return "こんにちは";
    }
    else if (hour >= 17 || hour <= 3) {
        return "こんばんは";
    }
}
```

### 重要ポイント
- `&&` (AND): 両方の条件を満たす必要がある
- `||` (OR): どちらか一方の条件を満たせばOK
- 夜の時間帯（17時-翌3時）は日をまたぐため`||`を使う

---

## 2. デフォルトパラメータ

### 概要
関数に引数が渡されなかった場合に使用される初期値を設定する機能。

### コード例
```javascript
function greet(name = "ゲスト") {
    return "こんにちは" + name + "さん";
}

console.log(greet("太郎"));  // "こんにちは太郎さん"
console.log(greet());        // "こんにちはゲストさん"
```

### 重要ポイント
- `function 関数名(引数 = デフォルト値)` の形式
- 引数が`undefined`の場合、自動的にデフォルト値が使われる
- if文で条件分岐するより簡潔に書ける

### 比較
```javascript
// デフォルトパラメータなし（冗長）
function greet(name) {
    if (name === undefined) {
        name = "ゲスト";
    }
    return "こんにちは" + name + "さん";
}

// デフォルトパラメータあり（簡潔）
function greet(name = "ゲスト") {
    return "こんにちは" + name + "さん";
}
```

---

## 3. Math.random()とMath.floor()

### 概要
ランダムな数値を生成し、整数に変換する方法。

### Math.random()
- `0以上1未満`のランダムな小数を生成
- 例: `0.234`, `0.789`, `0.001`

```javascript
console.log(Math.random());  // 0.5472... など
```

### Math.floor()
- 小数点以下を切り捨てて整数にする
- 例: `Math.floor(2.8)` → `2`

```javascript
console.log(Math.floor(2.8));  // 2
console.log(Math.floor(1.3));  // 1
console.log(Math.floor(0.1));  // 0
```

### 組み合わせて使う
```javascript
// 0, 1, 2 のいずれかをランダムに生成
const randomIndex = Math.floor(Math.random() * 3);

// 仕組み：
// Math.random() → 0以上1未満（例: 0.234）
// * 3 → 0以上3未満（例: 0.702）
// Math.floor() → 小数点切り捨て（例: 0）
```

---

## 4. 配列からランダム選択

### 概要
配列に複数の要素を保存し、そこからランダムに1つを選択する方法。

### コード例
```javascript
const messages = [
    "おはよう",
    "いい朝だね",
    "よく寝れた？"
];

// ランダムなインデックス（0, 1, 2のいずれか）を生成
const randomIndex = Math.floor(Math.random() * 3);

// 配列から取得
return messages[randomIndex];
```

### 配列の長さを使う（より汎用的）
```javascript
const messages = ["A", "B", "C", "D", "E"];

// 配列の長さ（5）を使ってランダム選択
const randomIndex = Math.floor(Math.random() * messages.length);
return messages[randomIndex];
```

### 重要ポイント
- 配列のインデックスは`0`から始まる
- `messages.length`を使うと、要素数が変わっても対応できる
- `messages[0]`, `messages[1]`, `messages[2]` で各要素にアクセス

---

## 5. カロリー摂取量に応じたコメント出し分け

### 概要
目標カロリーに対する実際の摂取カロリーの割合を計算し、5段階でコメントを出し分ける機能。

### 設計（Chalorieの基準）
| レベル | 摂取率 | 状態 |
|--------|--------|------|
| 1 | 0-60% | 極度の栄養不足 |
| 2 | 60-80% | やや不足 |
| 3 | 80-120% | 理想的 ✓ |
| 4 | 120-150% | 食べ過ぎ |
| 5 | 150%+ | 極度の食べ過ぎ |

### コード例
```javascript
function getHealthComment(actual, target) {
    // 摂取率を計算
    const ratio = (actual / target) * 100;

    if (ratio < 60) {
        const healthComment = [
            "栄養が足りないよ〜💦 しっかり食べよう！",
            "エネルギー不足かも…ごはん食べて元気出そ🐧",
            "お腹空いてない？もう少し食べた方がいいよ！"
        ];
        const randomComment = Math.floor(Math.random() * 3);
        return healthComment[randomComment];
    }
    // 他のレベルも同様に...
}
```

### 重要ポイント
- `ratio = (actual / target) * 100` で摂取率（%）を計算
- 各レベルに複数のコメントを用意してランダム選択
- 毎回違うコメントが表示されるので、飽きにくい

---

## 6. オブジェクト設計

### 概要
関連するデータをオブジェクトにまとめて管理する方法。

### 良い設計例
```javascript
const person = {
    name: "優太",
    age: 30,
    job: "sales",
    city: "Asagaya",
    gender: "male",
    food: ["sushi", "yakiniku", "ramen"],
    calorieInfo: {
        target: 2000,
        actual: 1800
    }
};
```

### アクセス方法
```javascript
console.log(person.name);                    // "優太"
console.log(person.calorieInfo.target);      // 2000
console.log(person.calorieInfo.actual);      // 1800
console.log(person.food[0]);                 // "sushi"
```

### 重要ポイント
- データの関連性を考えて構造化する
- `person.calorieInfo`のように、ネストしたオブジェクトも作れる
- 論理的に整理されていると、後で保守しやすい

### 悪い設計例
```javascript
// バラバラに定義（管理が大変）
const name = "優太";
const age = 30;
const targetCalorie = 2000;
const actualCalorie = 1800;
```

---

## 7. 関数の組み合わせ

### 概要
複数の関数を組み合わせて、より複雑な機能を実現する方法。

### コード例
```javascript
// 時間帯の挨拶を返す関数
function getGreetMessage(hour) {
    // ... 省略
    return "こんにちは";
}

// カロリーコメントを返す関数
function getHealthComment(actual, target) {
    // ... 省略
    return "いい感じ〜！健康的だね🐧";
}

// 2つの関数を組み合わせた最終的な挨拶
function greet(name = "ゲスト") {
    return getGreetMessage(now.getHours())
        + name
        + "さん。"
        + getHealthComment(person.calorieInfo.actual, person.calorieInfo.target);
}

console.log(greet("優太"));
// 出力例: "こんにちは優太さん。いい感じ〜！健康的だね🐧"
```

### 重要ポイント
- 各関数は1つの責任を持つ（単一責任の原則）
- `getGreetMessage`: 時間帯の挨拶のみを担当
- `getHealthComment`: カロリーコメントのみを担当
- `greet`: 2つを組み合わせる役割
- 関数を小さく保つと、再利用しやすく、テストしやすい

---

## 8. その他の学習ポイント

### セミコロン（;）
- 文（statement）の終わりに付ける
- JavaScriptは自動挿入してくれるが、明示的に書く方が良い
- 統一性が大切

### 波括弧（{}）
- if文で1行だけなら省略可能だが、書いた方が安全
- 後で行を追加する時にエラーを防げる

### 変数の実行順序
- JavaScriptは上から下に実行される
- 変数は定義された後でないと使えない
- 関数内で使う変数は、関数呼び出しより前に定義する

---

## 9. DRY原則とリファクタリング

### 概要
DRY（Don't Repeat Yourself）原則：同じコードを繰り返し書かず、共通の処理を関数にまとめること。

### 問題：コードの重複
最初のコードでは、配列からランダムに選ぶ処理が何度も繰り返されていた。

```javascript
// getGreetMessage関数内で
const randomIndex = Math.floor(Math.random() * 3);
return message[randomIndex];

// getHealthComment関数内でも同じコードが5回
const randomComment = Math.floor(Math.random() * 3);
return healthComment[randomComment];
```

### 解決策：共通処理を関数化
繰り返し出てくる処理を1つの関数にまとめた。

```javascript
function random(message) {
    const randomIndex = Math.floor(Math.random() * message.length);
    return message[randomIndex];
}
```

### リファクタリング後
```javascript
// 変更前（2行）
const randomIndex = Math.floor(Math.random() * 3);
return message[randomIndex];

// 変更後（1行）
return random(message);
```

### メリット
1. **コードが短くなる**: 2行が1行になり、読みやすくなる
2. **保守性が高い**: ロジックを変更する時、1箇所だけ修正すればOK
3. **汎用性が高い**: `message.length`を使うことで、どんな長さの配列にも対応
4. **バグが減る**: 同じコードを何度も書くと、タイプミスの可能性が増える

### 実例
```javascript
// getGreetMessage関数
function getGreetMessage(hour) {
    if (hour >= 4 && hour <= 10) {
        const message = ["おはよう", "いい朝だね", "よく寝れた？"];
        return random(message);  // シンプル！
    }
    // ...
}

// getHealthComment関数
function getHealthComment(actual, target) {
    const ratio = (actual / target) * 100;
    if (ratio < 60) {
        const message = [
            "栄養が足りないよ〜💦 しっかり食べよう！",
            "エネルギー不足かも…ごはん食べて元気出そ🐧",
            "お腹空いてない？もう少し食べた方がいいよ！"
        ];
        return random(message);  // 同じ関数を再利用！
    }
    // ...
}
```

### 重要ポイント
- 同じようなコードが3回以上出てきたら、関数化を検討する
- 関数名は処理内容がわかるように（`random`は配列からランダム選択）
- パラメータを工夫して汎用的に（`* 3`ではなく`* message.length`）

### リファクタリングの流れ
1. 繰り返しパターンを見つける
2. 共通部分を抽出
3. 関数を作成
4. 元のコードを置き換え
5. 動作確認

---

## 🎯 実際に作成した機能

### greeting.js の最終形
1. **時間帯別の挨拶**（朝・昼・夜）
2. **各時間帯に3パターンのメッセージ**（ランダム表示）
3. **カロリー摂取量に応じた健康コメント**（5レベル × 3パターン）
4. **名前のデフォルト値設定**（引数なしでも動作）
5. **すべてを統合した最終的な挨拶文**

### 実行例
```
// actual: 1000 (50%) の場合
"こんにちは優太さん。栄養が足りないよ〜💦 しっかり食べよう！"

// actual: 2000 (100%) の場合
"おはよう優太さん。完璧なバランス✨ この調子！"

// actual: 4000 (200%) の場合
"こんばんは優太さん。うぅ…お腹パンパンだよ〜😵"
```

---

## 🚀 次のステップ

### Chalorieプロジェクトへの応用
今日学んだ`getHealthComment`関数のロジックは、実際のChalorieプロジェクトでそのまま使えます！

### さらに学びたい場合
- 配列の他のメソッド（map, filter, reduceなど）
- オブジェクトの操作（Object.keys, Object.valuesなど）
- 非同期処理（Promise, async/awaitなど）
- DOM操作（HTMLを動的に変更）

---

## 📝 復習のヒント

1. **実際に手を動かす**: コードを写すだけでなく、自分で書いてみる
2. **値を変えて実験**: `actual`の値を変えて、違う結果を確認
3. **エラーを恐れない**: エラーが出たら、メッセージを読んで理解する
4. **小さく始める**: 一度に全部実装せず、1つずつ機能を追加
5. **コメントを書く**: 自分の理解を日本語でコメントに残す

---

**作成日**: 2025-10-27
**プロジェクト**: JavaScript学習 - greeting.js
